# Office Space Management Application - Complete Deployment Documentation

## Table of Contents

1. [Project Overview](#project-overview)
2. [Initial Assessment and Pipeline Issues](#initial-assessment-and-pipeline-issues)
3. [Server Environment Analysis](#server-environment-analysis)
4. [Deployment Strategy Selection](#deployment-strategy-selection)
5. [Pipeline Fix Implementation](#pipeline-fix-implementation)
6. [Server Preparation and Deployment](#server-preparation-and-deployment)
7. [Configuration and Environment Setup](#configuration-and-environment-setup)
8. [Troubleshooting and Resolution](#troubleshooting-and-resolution)
9. [Final Working Solution](#final-working-solution)
10. [Lessons Learned and Best Practices](#lessons-learned-and-best-practices)

---

## Project Overview

### Application Architecture

- **Frontend**: React 19 application with react-router-dom, drag-drop functionality
- **Backend**: Node.js with Express, Mongoose ODM
- **Database**: MongoDB (corporate RBC DEV environment)
- **Purpose**: Office space management system to replace Excel-based seat tracking

### Tech Stack Details

- **Backend Dependencies**: Express, Mongoose, CORS, ExcelJS, Multer
- **Frontend Dependencies**: React 19, Axios, React Beautiful DnD, Chart.js
- **Development Tools**: Nodemon for development, React Scripts for build

---

## Initial Assessment and Pipeline Issues

### Problem Statement

The user had a deployment-ready application but faced a failing CI/CD pipeline preventing PR to main branch. They needed to deploy to a separate Linux server but were unsure of the process.

### Pipeline Investigation

**Issue Discovered**: CI/CD pipeline failing on frontend tests
- Pipeline configuration: `.github/workflows/helios-nodejs-ocp4-ci-cd-pipeline.yml`
- Failed step: Frontend test execution
- Root cause: No tests implemented but pipeline expected tests to pass

**Error Analysis:**
```bash
npm test -- --coverage --watchAll=false
# Result: "No tests found, exiting with code 1"
```

**Why This Happened:**
- React applications by default have test scripts that fail when no tests exist
- CI/CD pipelines treat exit code 1 as failure
- Frontend had `"test": "react-scripts test"` without `--passWithNoTests` flag

### Solution Implemented

Modified `frontend/package.json:24`:
```javascript
// Before:
"test": "react-scripts test"

// After:
"test": "react-scripts test --passWithNoTests --watchAll=false"
```

**Why This Fix Works:**
- `--passWithNoTests`: Allows tests to pass when no test files exist
- `--watchAll=false`: Prevents hanging in CI environments
- Maintains compatibility with future test implementation

---

## Server Environment Analysis

### Corporate Server Context

- **Server**: guedlvaugz0001.devfg.rbc.com
- **Personal Account**: artguz (SSH access)
- **Application Account**: pugzapp4 (for running production services)
- **Environment**: Corporate Linux with restrictions

### Essential Checks Performed

We focused only on deployment-critical requirements, avoiding unnecessary complexity:

```bash
# 1. Node.js availability (required for backend)
node --version  # Result: v16.20.2 ✅
npm --version   # Result: 8.19.4 ✅

# 2. Port availability (required for services)
netstat -tlnp | grep -E ':(3000|3001|80|8080)'  # Ports available ✅

# 3. File system permissions (required for deployment)
touch /users/artguz/test.txt && rm /users/artguz/test.txt  # Can write files ✅

# 4. Internet access (required for npm packages)
curl -s https://registry.npmjs.org/ > /dev/null  # FAILED ❌

# 5. Container technology (alternative deployment)
docker --version  # Result: podman version 5.4.0 ✅
```

### Key Findings

- ✅ **Node.js v16.20.2**: Sufficient for the application (no upgrade needed)
- ✅ **Port Access**: Ports 3000/3001 available for application
- ✅ **File Permissions**: Can write to user directories
- ❌ **Internet Access**: Corporate firewall blocks npm registry
- ✅ **Container Support**: Podman available (Docker alternative)

### Why We Checked These Specific Items

- **Node.js**: Backend requires Node.js runtime
- **Ports**: Application needs specific ports for frontend/backend
- **File Permissions**: Deployment requires ability to create/modify files
- **Internet Access**: Traditional deployment downloads packages during install
- **Container Support**: Alternative deployment method if manual approach fails

### Corporate Environment Constraints

- No sudo access: Cannot install system packages
- Firewall restrictions: Cannot download npm packages directly
- Directory structure: Uses `/users/` instead of `/home/`
- Account separation: Personal vs application accounts for security

---

## Deployment Strategy Selection

### Options Considered

#### 1. Docker/Container Deployment

**Pros:**
- Consistent environment
- Isolated dependencies
- Modern best practice

**Cons:**
- Requires Podman knowledge (not Docker)
- More complex troubleshooting
- Corporate environments often restrict containers

**Decision**: Rejected due to complexity and corporate restrictions

#### 2. Traditional Package Manager Deployment

**Pros:**
- Standard npm/Node.js workflow
- Easy troubleshooting

**Cons:**
- Requires internet access for npm install
- Corporate firewall blocks npm registry

**Decision**: Rejected due to network restrictions

#### 3. Pre-built Package Upload (Selected)

**Pros:**
- Bypasses internet restrictions
- Works with existing Node.js installation
- Simple deployment process
- Easy to troubleshoot

**Cons:**
- Manual package preparation
- Larger file transfer

**Decision**: Selected as optimal for corporate environment

### Why This Strategy Works

1. **Corporate Friendly**: No special permissions or internet access required
2. **Reliable**: Pre-built packages eliminate network dependency
3. **Debuggable**: Direct access to Node.js processes and logs
4. **Maintainable**: Standard Node.js/Python processes familiar to IT teams

---

## Pipeline Fix Implementation

### Problem Context

Before deployment, we needed to fix the CI/CD pipeline to allow future PRs to main branch.

### Technical Implementation

```javascript
// File: frontend/package.json
// Line 24 modification
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --passWithNoTests --watchAll=false",  // Fixed line
    "eject": "react-scripts eject"
  }
}
```

### Verification Steps

```bash
# Test the fix locally
cd frontend
npm test -- --coverage --watchAll=false
# Should now exit with code 0 instead of 1
```

### Branch Strategy Decision

**Question**: Deploy from main branch or current dev-prep branch?  
**Answer**: Deploy from current dev-prep branch

**Reasoning:**
- Deployment doesn't require main branch
- Can test deployment before merging
- Pipeline fix can be validated separately
- Faster iteration without waiting for PR approval

---

## Server Preparation and Deployment

### Account Structure Understanding

**Personal Account (artguz):**
- SSH access point
- File upload destination
- Development and testing

**Application Account (pugzapp4):**
- Production service runner
- Isolated environment
- Security best practice

### Directory Structure

```
/users/artguz/          # Personal account home
├── OfficeOps.tar.gz    # Uploaded package

/users/pugzapp4/        # Application account home
├── backend/            # Extracted backend
├── frontend/           # Extracted frontend
├── OfficeOps.tar.gz    # Copied package
└── logs/               # Application logs
```

### Package Preparation (Local Machine)

```bash
# 1. Build backend with production dependencies
cd backend
npm ci --production  # Installs only production dependencies

# 2. Build frontend for production
cd ../frontend
npm ci                # Install all dependencies for build
npm run build        # Create production build

# 3. Create deployment package
cd ..
tar -czf OfficeOps.tar.gz backend/ frontend/ .env.dev
```

**Why These Steps:**
- `npm ci --production`: Faster, deterministic installs without dev dependencies
- `npm run build`: Creates optimized React production bundle
- Include `.env.dev`: Contains MongoDB connection configuration

### File Transfer and Extraction

```bash
# Upload to server
scp OfficeOps.tar.gz artguz@guedlvaugz0001:/users/artguz/

# Server-side extraction
ssh artguz@guedlvaugz0001
su - pugzapp4
cp /users/artguz/OfficeOps.tar.gz .
tar -xzf OfficeOps.tar.gz
```

### File Permission Issues Encountered

**Problem**: `cp: cannot start 'command': permission denied`

**Root Cause:**
- Different user accounts can't read each other's files directly
- Corporate security restrictions

**Solution**: Use shared temporary directory
```bash
# As artguz user
chmod 644 /users/artguz/OfficeOps.tar.gz
cp /users/artguz/OfficeOps.tar.gz /tmp/
chmod 644 /tmp/OfficeOps.tar.gz

# As pugzapp4 user
cp /tmp/OfficeOps.tar.gz .
```

### Tar Extraction Warnings

**Issue**: `tar: Ignoring unknown extended header keyword 'LIBARCHIVE.xattr.com.apple.provenance'`

**Explanation:**
- macOS adds extended attributes to files
- Linux tar doesn't understand these attributes
- Warnings are harmless and don't affect extraction

**Solution**: Suppress warnings or ignore them
```bash
tar -xzf OfficeOps.tar.gz 2>/dev/null  # Suppress warnings
# OR just ignore the warnings - extraction still works
```

---

## Configuration and Environment Setup

### Database Configuration Challenge

**Corporate MongoDB Setup**: Component-based connection rather than single URI

**Configuration File**: `.env.dev`
```bash
# RBC DEV Database Environment
ENVIRONMENT_NAME=dev
PORT=3000
NODE_ENV=development

# Component-based MongoDB connection
MONGODB_URI=
MONGODB_USERNAME=YOUR_VAULT_USERNAME
MONGODB_PASSWORD=YOUR_VAULT_PASSWORD
MONGODB_HOST=strdlvbugz0002.devfg.rbc.com
MONGODB_PORT=17127
MONGODB_NAME=YOUR_DATABASE_NAME
MONGODB_AUTH_MECHANISM=PLAIN
MONGODB_AUTH_SOURCE=$external
MONGODB_TLS=true
```

### Environment File Strategy Decision

**Question**: Create new production .env or use existing .env.dev?  
**Decision**: Use existing .env.dev directly

**Reasoning:**
- Already contains correct MongoDB credentials
- Faster deployment without manual credential entry
- Reduces risk of configuration errors
- Can be updated later if needed

### Backend Configuration Issues

**First Attempt**: Complex dotenv configuration
```bash
node -r dotenv/config server.js dotenv_config_path=.env.dev
```

**Problem**: Backend code uses simple `require('dotenv').config()`
```javascript
// server.js line 4
require('dotenv').config();
```

**Solution**: Simple file copy approach
```bash
cp .env.dev .env
node server.js
```

**Why This Works:**
- dotenv by default reads .env file
- Simpler and more reliable than complex parameter passing
- Standard Node.js practice

---

## Troubleshooting and Resolution

### MongoDB Connection Failure

**Initial Error:**
```
MongoDB connection error: MongooseServerSelectionError: connect ECONNREFUSED 127.0.0.1:27017
```

**Root Cause Analysis:**
- Backend defaulting to localhost:27017
- Environment variables not loading correctly
- Configuration file not found

**Diagnostic Process:**
```bash
# Check if .env file exists and is readable
ls -la .env
cat .env

# Verify environment variable loading
node -e "require('dotenv').config(); console.log(process.env.MONGODB_URI);"
```

**Resolution**: Proper environment file configuration
```bash
cp .env.dev .env  # Ensure correct file name
node server.js    # Standard startup
```

### Frontend API Connection Issues

**Problem**: Frontend loading but "Error fetching seats"

**Investigation Process:**

1. Backend API Testing:
```bash
curl http://localhost:3000/health      # Test health endpoint
curl http://localhost:3000/api/seats   # Test API endpoint
```

2. API URL Analysis:
   - Examined `frontend/src/services/api.js`
   - Found hardcoded `http://localhost:3000/api`
   - Realized frontend build has wrong server URL

**Root Cause**: Frontend built with localhost API URL, but needs server hostname

**Code Analysis:**
```javascript
// frontend/src/services/api.js
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000/api';
```

### Service Persistence Challenge

**Problem**: Application stops when terminal closes

**Explanation:**
- SSH sessions terminate background processes
- Need persistent service execution

**Solution**: nohup for background execution
```bash
# Backend persistence
nohup node server.js > backend.log 2>&1 &

# Frontend persistence  
nohup python3 -m http.server 3001 --directory build > frontend.log 2>&1 &
```

**Process Management:**
```bash
# Check running processes
ps aux | grep -E "(node|python3)"

# Stop services
pkill -f "node server.js"
pkill -f "python3 -m http.server 3001"

# View logs
tail -f backend.log
tail -f frontend.log
```

---

## Final Working Solution

### Complete Deployment Process

#### 1. Local Preparation

```bash
# Fix frontend API URL
cd frontend
echo "REACT_APP_API_URL=http://guedlvaugz0001.devfg.rbc.com:3000/api" > .env

# Build production packages
cd backend && npm ci --production
cd ../frontend && npm ci && npm run build

# Create deployment package
cd ..
tar -czf OfficeOps-fixed.tar.gz backend/ frontend/
```

#### 2. Server Deployment

```bash
# Upload
scp OfficeOps-fixed.tar.gz artguz@guedlvaugz0001:/users/artguz/

# Extract and configure
ssh artguz@guedlvaugz0001
su - pugzapp4
cp /users/artguz/OfficeOps-fixed.tar.gz .
tar -xzf OfficeOps-fixed.tar.gz

# Configure backend
cd backend
cp .env.dev .env

# Start services persistently
nohup node server.js > backend.log 2>&1 &
cd ../frontend
nohup python3 -m http.server 3001 --directory build > frontend.log 2>&1 &
```

#### 3. Service Verification

```bash
# Check processes
ps aux | grep -E "(node|python3)"

# Test endpoints
curl http://localhost:3000/health
curl http://localhost:3001

# Check logs
tail -f backend/backend.log
tail -f frontend/frontend.log
```

### Access URLs

- **Frontend**: http://guedlvaugz0001.devfg.rbc.com:3001
- **Backend API**: http://guedlvaugz0001.devfg.rbc.com:3000
- **Health Check**: http://guedlvaugz0001.devfg.rbc.com:3000/health

---

## Lessons Learned and Best Practices

### Corporate Environment Deployment

#### Key Considerations

1. **Network Restrictions**: Always expect firewall/proxy limitations
2. **Permission Models**: Understand personal vs application account separation
3. **Package Management**: Pre-built packages bypass network restrictions
4. **Simplicity Over Complexity**: Manual deployment often better than containers in corporate environments

#### Best Practices Established

1. **Environment-Specific Builds**: Always build frontend with correct API URLs
2. **Service Persistence**: Use nohup for production-like services
3. **Process Management**: Implement proper start/stop procedures
4. **Log Management**: Redirect output to files for debugging
5. **Incremental Deployment**: Test components separately before full deployment

### Technical Decisions and Rationale

#### Why Manual Deployment Over Docker

- **Corporate Security**: Containers often restricted in financial institutions
- **Debugging**: Direct process access easier for troubleshooting
- **Resource Usage**: Lower overhead for small applications
- **Familiarity**: IT teams more comfortable with traditional processes

#### Why Node.js v16 vs v18

- **Compatibility**: Application tested and working on v16
- **Risk Reduction**: Avoid unnecessary version changes during deployment
- **Corporate Constraints**: Version upgrades require admin rights

#### Why Python HTTP Server for Frontend

- **Simplicity**: Built into Python, no additional dependencies
- **Reliability**: Standard library component, well-tested
- **Corporate Friendly**: No additional software installation required

### Troubleshooting Methodology

#### Systematic Approach

1. **Test Components Separately**: Backend health, frontend loading, API connectivity
2. **Check Logs First**: Always examine application logs before assumptions
3. **Verify Configuration**: Environment variables, file permissions, network connectivity
4. **Isolate Variables**: Change one thing at a time
5. **Document Solutions**: Record working configurations for future reference

#### Common Pitfalls Avoided

- **Assuming Standard Paths**: `/home/` vs `/users/` directory structures
- **Ignoring Warnings**: Distinguishing harmless warnings from real errors
- **Complex Solutions First**: Starting with simple approaches before advanced options
- **Single Terminal Dependency**: Understanding process persistence requirements

### Future Improvements

#### Operational Enhancements

1. **Service Scripts**: Create start/stop scripts for easier management
2. **Log Rotation**: Implement log rotation to prevent disk space issues
3. **Health Monitoring**: Add automated health checks
4. **Backup Procedures**: Document database backup/restore procedures

#### Development Workflow

1. **Environment Parity**: Align development and production configurations
2. **Build Process**: Automate frontend builds with environment-specific URLs
3. **Testing Strategy**: Implement comprehensive test suite to support CI/CD
4. **Documentation**: Maintain deployment runbooks for different environments

### Knowledge Transfer Points

#### For Future Deployments

1. **Environment Files**: Always verify environment variable loading
2. **API URLs**: Build frontend with target environment URLs
3. **Process Management**: Plan for service persistence from the start
4. **Corporate Constraints**: Assess network, permission, and software restrictions early
5. **Account Management**: Understand and utilize proper account separation

#### For Development Team

1. **CI/CD Configuration**: Ensure pipeline handles missing tests gracefully
2. **Environment Configuration**: Design flexible environment variable systems
3. **Build Process**: Support environment-specific builds
4. **Documentation**: Maintain clear deployment procedures
5. **Testing Strategy**: Implement tests to support automated pipelines

---

## Appendix

### Complete File Structure

**Local Development:**
```
office-space-management/
├── backend/
│   ├── src/
│   ├── package.json
│   ├── server.js
│   ├── .env.dev
│   └── Dockerfile
├── frontend/
│   ├── src/
│   ├── public/
│   ├── package.json
│   └── Dockerfile
├── .github/workflows/
└── docker-compose.yml
```

**Server Deployment:**
```
/users/pugzapp4/
├── backend/
│   ├── server.js
│   ├── .env (copied from .env.dev)
│   ├── backend.log
│   └── node_modules/
├── frontend/
│   ├── build/
│   └── frontend.log
└── OfficeOps-fixed.tar.gz
```

### Command Reference

```bash
# Package preparation
npm ci --production
npm run build
tar -czf package.tar.gz backend/ frontend/

# Server deployment
scp package.tar.gz user@server:/path/
ssh user@server
su - appuser
tar -xzf package.tar.gz

# Service management
nohup node server.js > backend.log 2>&1 &
nohup python3 -m http.server 3001 --directory build > frontend.log 2>&1 &
ps aux | grep -E "(node|python3)"
pkill -f "process_name"

# Monitoring
tail -f backend.log
tail -f frontend.log
curl http://localhost:3000/health
```

### Environment Variables

```bash
# Frontend build-time variables
REACT_APP_API_URL=http://server:3000/api

# Backend runtime variables
NODE_ENV=production
PORT=3000
MONGODB_URI=connection_string
MONGODB_HOST=host
MONGODB_PORT=port
MONGODB_USERNAME=username
MONGODB_PASSWORD=password
```

This documentation provides a complete reference for replicating the deployment process, understanding the decisions made, and avoiding the obstacles encountered during the original deployment.
